- [编译原理](#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86)
- [理解作用域](#%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F)
  - [概念：](#%E6%A6%82%E5%BF%B5)
  - [代码执行实例：`var a=1;`](#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AE%9E%E4%BE%8Bvar-a1)
  - [引擎执行的查找](#%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9F%A5%E6%89%BE)
  - [作用域嵌套](#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B5%8C%E5%A5%97)
  
作用域是一个用于解释JS中的变量存储在哪里，程序如何找到需要的变量的一个概念。

### 编译原理

JS是通常被归类为动态或解释执行语言，但是其本身是一门**编译语言**。  
但是其不是提前编译，也无法在分布式系统中进行移植。  
* 其编译步骤可以分为以下三步：
    * 分词/词法分析： 将代码分为基础的词法单元（token）。
        * `var a=1;`=>`var、a、=、1、;`
    * 解析/语法分析： 将token转为有意义的语法树。
        * 构建一颗语法树  var->a、=->1 
    * 代码生成：将语法树转为可执行代码
        * 将语法树转为机器指令，创建一个a变量并且赋值为1

### 理解作用域

#### 概念：  
所有代码的执行需要 引擎，编译器，作用域 三者的参与。  
其中引擎负责JS程序的编译和执行。  
编译器负责词法分析，代码生成等。  
作用域负责收集和维护由所有变量组成的一系列查询，并有自己的一套规则。  

#### 代码执行实例：`var a=1;`  

`var a` 首先编译器查询作用域是否存在a变量，如果在当前作用域已存在a变量，则忽略声明，继续编译，否则声明一个新的变量，命名为a  
`a=1` 首先引擎查询当前作用域链上是否存在a变量，如果存在，给其赋值为1，否则报错  

#### 引擎执行的查找

LHS查找：当变量位于赋值操作左侧进行，找到操作的对象  
RHS查找：当变量位于赋值操作右侧进行，找到操作对应的具体值。

#### 作用域嵌套

每一个块或函数都有自己的作用域，多个块或函数产生嵌套也就是作用域嵌套  
LHS 和 RHS 查询都会在当前执行作用域中开始,如果有需要(也就是说它们没有找到所 需的标识符),就会向上级作用域继续查找目标标识符,这样每次上升一级作用域(一层 楼),最后抵达全局作用域(顶层),无论找到或没找到都将停止。  
不成功的RHS引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(非严格模式下),或抛出异常(严格模式下)。